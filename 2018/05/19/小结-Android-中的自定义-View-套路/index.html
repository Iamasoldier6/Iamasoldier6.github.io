<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>小结 Android 中的自定义 View 套路 | Iamasoldier6&#39;s Column</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="君子藏器于身，待时而动。

Android 中的自定义 View，是个老生常谈的话题了，从简单到复杂的，应有尽有。原生控件满足不了需求，网上找到的 Demo 有所欠缺时，往往需要我们撸起袖子自己干。不过，所谓万变不离其宗，返璞归真，一般也就那些套路，深入理解套路，并勤加练习，相信随着时间的洗礼，自会更上一层楼。">
<meta property="og:type" content="article">
<meta property="og:title" content="小结 Android 中的自定义 View 套路">
<meta property="og:url" content="http://iamasoldier6.com/2018/05/19/小结-Android-中的自定义-View-套路/index.html">
<meta property="og:site_name" content="Iamasoldier6's Column">
<meta property="og:description" content="君子藏器于身，待时而动。

Android 中的自定义 View，是个老生常谈的话题了，从简单到复杂的，应有尽有。原生控件满足不了需求，网上找到的 Demo 有所欠缺时，往往需要我们撸起袖子自己干。不过，所谓万变不离其宗，返璞归真，一般也就那些套路，深入理解套路，并勤加练习，相信随着时间的洗礼，自会更上一层楼。">
<meta property="og:image" content="https://i.loli.net/2019/03/03/5c7b80d4d728b.jpg">
<meta property="og:updated_time" content="2019-03-03T11:13:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小结 Android 中的自定义 View 套路">
<meta name="twitter:description" content="君子藏器于身，待时而动。

Android 中的自定义 View，是个老生常谈的话题了，从简单到复杂的，应有尽有。原生控件满足不了需求，网上找到的 Demo 有所欠缺时，往往需要我们撸起袖子自己干。不过，所谓万变不离其宗，返璞归真，一般也就那些套路，深入理解套路，并勤加练习，相信随着时间的洗礼，自会更上一层楼。">
<meta name="twitter:image" content="https://i.loli.net/2019/03/03/5c7b80d4d728b.jpg">
  
    <link rel="alternative" href="/atom.xml" title="Iamasoldier6&#39;s Column" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xt0ac.com1.z0.glb.clouddn.com/shiba.jpeg">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://i.loli.net/2019/03/03/5c7b849a196a0.jpeg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Iamasoldier6</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Forged from suffering, hardened by pain.</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
							<li><a href="/about">关于我</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Iamasoldier6" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="https://www.weibo.com/2253797763/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Iamasoldier6" title="zhihu">zhihu</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/Iamasoldier6" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/AOSP/" style="font-size: 10px;">AOSP</a> <a href="/tags/Activity/" style="font-size: 11.43px;">Activity</a> <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Annotation/" style="font-size: 10px;">Annotation</a> <a href="/tags/Annual/" style="font-size: 11.43px;">Annual</a> <a href="/tags/Application/" style="font-size: 10px;">Application</a> <a href="/tags/Bundle/" style="font-size: 10px;">Bundle</a> <a href="/tags/Callback/" style="font-size: 10px;">Callback</a> <a href="/tags/Concurrency/" style="font-size: 12.86px;">Concurrency</a> <a href="/tags/Context/" style="font-size: 10px;">Context</a> <a href="/tags/Debug/" style="font-size: 10px;">Debug</a> <a href="/tags/DialogFragment/" style="font-size: 10px;">DialogFragment</a> <a href="/tags/Event/" style="font-size: 11.43px;">Event</a> <a href="/tags/EventBus/" style="font-size: 11.43px;">EventBus</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/Fragment/" style="font-size: 11.43px;">Fragment</a> <a href="/tags/Framework/" style="font-size: 10px;">Framework</a> <a href="/tags/Generics/" style="font-size: 10px;">Generics</a> <a href="/tags/Google/" style="font-size: 10px;">Google</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/tags/HashMap/" style="font-size: 11.43px;">HashMap</a> <a href="/tags/I-O/" style="font-size: 10px;">I/O</a> <a href="/tags/Image/" style="font-size: 12.86px;">Image</a> <a href="/tags/Java/" style="font-size: 17.14px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Launch/" style="font-size: 10px;">Launch</a> <a href="/tags/ListView/" style="font-size: 10px;">ListView</a> <a href="/tags/Mac/" style="font-size: 12.86px;">Mac</a> <a href="/tags/Message/" style="font-size: 10px;">Message</a> <a href="/tags/Parameter/" style="font-size: 10px;">Parameter</a> <a href="/tags/Pattern/" style="font-size: 11.43px;">Pattern</a> <a href="/tags/Performance/" style="font-size: 11.43px;">Performance</a> <a href="/tags/React-Native/" style="font-size: 10px;">React Native</a> <a href="/tags/RecyclerView/" style="font-size: 15.71px;">RecyclerView</a> <a href="/tags/Reflection/" style="font-size: 10px;">Reflection</a> <a href="/tags/Source-Code/" style="font-size: 18.57px;">Source Code</a> <a href="/tags/Summary/" style="font-size: 11.43px;">Summary</a> <a href="/tags/Text/" style="font-size: 10px;">Text</a> <a href="/tags/TypeScript/" style="font-size: 10px;">TypeScript</a> <a href="/tags/Unit-Test/" style="font-size: 10px;">Unit Test</a> <a href="/tags/View/" style="font-size: 11.43px;">View</a> <a href="/tags/Volley/" style="font-size: 14.29px;">Volley</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Iamasoldier6</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="https://i.loli.net/2019/03/03/5c7b849a196a0.jpeg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Iamasoldier6</h1>
			</hgroup>
			
			<p class="header-subtitle">Forged from suffering, hardened by pain.</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
					<li><a href="/about">关于我</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Iamasoldier6" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="https://www.weibo.com/2253797763/profile?rightmod=1&wvr=6&mod=personinfo" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/people/Iamasoldier6" title="zhihu">zhihu</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/Iamasoldier6" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-小结-Android-中的自定义-View-套路" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/19/小结-Android-中的自定义-View-套路/" class="article-date">
  	<time datetime="2018-05-19T04:07:16.000Z" itemprop="datePublished">2018-05-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      小结 Android 中的自定义 View 套路
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View/">View</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简要介绍"><span class="toc-number">1.</span> <span class="toc-text">简要介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#完全自定义的组件"><span class="toc-number">2.</span> <span class="toc-text">完全自定义的组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承-onDraw-和-onMeasure"><span class="toc-number">2.1.</span> <span class="toc-text">继承 onDraw() 和 onMeasure()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复合控制"><span class="toc-number">3.</span> <span class="toc-text">复合控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修改存在的视图类型"><span class="toc-number">4.</span> <span class="toc-text">修改存在的视图类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-number">5.</span> <span class="toc-text">参考文献</span></a></li></ol>
  </div>

        <blockquote>
<p>君子藏器于身，待时而动。</p>
</blockquote>
<p>Android 中的自定义 View，是个老生常谈的话题了，从简单到复杂的，应有尽有。原生控件满足不了需求，网上找到的 Demo 有所欠缺时，往往需要我们撸起袖子自己干。不过，所谓万变不离其宗，返璞归真，一般也就那些套路，深入理解套路，并勤加练习，相信随着时间的洗礼，自会更上一层楼。<a id="more"></a></p>
<p><strong>以下大多内容翻译及加工自<a href="https://developer.android.com/guide/topics/ui/custom-components" target="_blank" rel="external">官网</a></strong>。</p>
<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a><strong>简要介绍</strong></h2><p>Android 在基于基础布局类 <strong>View</strong> 和 <strong>ViewGroup</strong> 之上，提供了一个复杂且强大的组件模型来构建我们的 UI。一开始，平台包括了一系列预构建的 View 和 ViewGroup 子类，称作控件和布局，尤其可以用来构造我们的 UI。</p>
<ul>
<li>可用控件的部分清单包括 <strong><em>Button</em></strong>、<strong><em>TextView</em></strong>、<strong><em>EditText</em></strong>、<strong><em>ListView</em></strong>、<strong><em>CheckBox</em></strong>、<strong><em>RadioButton</em></strong>、<strong><em>Gallery</em></strong>、<strong><em>Spinner</em></strong> 和更具有特殊目的的 <strong><em>AutoCompleteTextView</em></strong>、<strong><em>ImageSwitcher</em></strong> 与 <strong><em>TextSwitcher</em></strong> 等</li>
<li>可用的布局如 <strong><em>LinearLayout</em></strong>、<strong><em>FrameLayout</em></strong> 和 <strong><em>RelativeLayout</em></strong> 等</li>
</ul>
<p>当然，若没有满足需求的预构建的控件或布局，我们可以创建自己的 View 子类。若只需要对现有的控件或布局做一些小的修改，则可以继承相应的控件或布局并重写其方法。</p>
<p>创建 View 的子类可以精确地控制到屏幕元素的外观和功能。为了给出一些控制自定义 View 的 idea，下面是一些例子：</p>
<ul>
<li>可以创建一个完全自定义渲染的 View 类型，如使用 2D 图像渲染的音量控制旋钮，其像一个模拟的电子控制</li>
<li>可以将一组 View 组件组装成新的单一组件，大概如新建一个 ComboBox (一个弹出列表和自由输入文本区域的组合)，亦或一个双面板的选择器控制开关 (一个带有列表的左右面板，在不同的列表里重组 item)</li>
<li>可以重写 EditText 组件渲染在屏幕上的方式</li>
<li>可以捕获事件如键压，然后以自定义的方式处理它们</li>
</ul>
<p>接下来的部分要讲到如何创建自定义 View，然后在应用中使用它们。更多详情，需要参见 View 类。</p>
<p>##<strong>基本方式</strong></p>
<p>下面是高层级的综述，关于开始创建自定义 View 组件所需要知道的东西：</p>
<ul>
<li>以新建的类继承现有的 View 类或其子类</li>
<li>重写父类的一些方法。需要重写的父类方法以 “on” 开头，如 <strong>onDraw()</strong>、<strong>onMeasure()</strong> 和 <strong>onKeyDown()</strong>。这和在 Activity 或 ListActivity 中为了生命周期和别的功能连接的 on… 事件很相像</li>
<li>使用新的继承类。一旦完成了，新的继承类可以用来代替其基于的 View 类</li>
</ul>
<p><strong>注意</strong>，在 Activities 里使用的话，继承类可以定义为内部类。这在控制其入口的地方很有用，但不是必须的 (或许是想在应用中新建一个更广使用范围的新的公用 View)。</p>
<h2 id="完全自定义的组件"><a href="#完全自定义的组件" class="headerlink" title="完全自定义的组件"></a><strong>完全自定义的组件</strong></h2><p>完全自定义的组件可以用来创建图像元素，以我们希望的样式显示。大概来说，一个图像式的音频壁纸看起来以旧的相似的规格，或者一个唱出的长文本，一个弹性球沿着语句移动，因此可以用卡拉 OK 的机器来唱歌。不管怎样，无论我们怎么组合现有植入的组件，我们想要的是已存在的组件做不到的。</p>
<p>幸运的是，我们可以创建以自己喜欢的方式表现的组件，或许限制我们的只是自己的想象力、屏幕的尺寸和可用的处理电力 (最终我们的应用应该以比桌面工作站更少电力的方式运行)。</p>
<p>好，总结如下，创建完全自定义的组件注意：</p>
<ul>
<li>要继承的最宽泛的视图，无疑是 View，故而我们应该继承它来创建我们自己的新的超级组件</li>
<li>可以提供一个构造器，其可以从 XML 中获取属性和参数，也可以使用自己动态设置的属性和参数 (或许是音频壁纸的颜色和范围，或者针状物的宽度和阻尼等)</li>
<li>可能想创建自己的事件监听器，性能存储器和修饰符，也可能是组件类中更复杂的行为</li>
<li>当然，要重写 <strong><em>onMeasure()</em></strong>，并且，想让组件展示东西的话，也需要重写 <strong><em>onDraw()</em></strong>。虽然都有自己默认的行为，默认的 onDraw() 什么都不做，但是，默认的 onMeasure() 总会设置一个 100x100 的尺寸，或许不是我们想要的</li>
<li>别的以 on… 开头的方法或许也按要求需要重写</li>
</ul>
<h3 id="继承-onDraw-和-onMeasure"><a href="#继承-onDraw-和-onMeasure" class="headerlink" title="继承 onDraw() 和 onMeasure()"></a><strong>继承 onDraw() 和 onMeasure()</strong></h3><p><strong><em>onDraw()</em></strong> 方法提供给我们一个 Canvas，我们可以在它上面实现任何想要的东西：2D 图像、别的标准的或自定义的组件，自带个性风格的 text，或任何能想到的东西。</p>
<p><strong>注意</strong>，这个不能应用于 3D 图像，假如想应用于 3D 图像的话，必须继承 SurfaceView，而不是简单地继承 View，在一个独立的线程绘制它。</p>
<p><strong><em>onMeasure()</em></strong> 的戏份会更多点，其在我们定义的组件和容器之间，是一块重要的渲染协议。onMeasure() 应该被重写，高效且精确地报告其所包括部分的测量。这有点复杂，被 parent 的要求所限制 (是被传递至 onMeasure() 方法的) ，同时，也被计算好宽度和高度的 <strong><em>setMeasuredDimension()</em></strong> 方法所限制。若忘了在重写的 onMeasure() 方法里调用这个方法，会在测量期间抛出个异常。</p>
<p>更高层级的，使用 <strong><em>onMeasure()</em></strong> 方法要注意以下：</p>
<ul>
<li>被重写的 onMeasure() 方法被调用时带有宽度和高度测量说明 (<code>widthMeasureSpec</code>和<code>heightMeasureSpec</code>参数，都是代表尺寸的整型值)，应该在生成宽度和高度的尺寸时，作为限制要求来对待。对这些说明限制种类的完整参考，可以在<code>View.onMeasure(int, int)</code>的参考文档中找到，文档中也把整个测量操作解释的很透彻</li>
<li>组件的 onMeasure() 方法应该计算一种测量宽度和高度，其被要求用来渲染组件。并且，它应该保持在传入说明里，尽管它可以选择越过它 (这种情况下，parent 可以选择做的包括如，裁剪、滚动、抛出异常或请求 onMeasure() 重新执行一次，或许有着不同的测量说明)</li>
<li>一旦宽度和高度计算完成，<code>setMeasuredDimension(int width, int height)</code>方法在被调用时，须带有计算好的测量值，没做的话会导致抛出异常</li>
</ul>
<p>下列表格是 framework 层在 views 上调用时，展现标准方法的总结：</p>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">创建 (Creation)</td>
<td style="text-align:left">Constructors</td>
<td>构造器的一种形式是，当 view 从代码中被创建出来，还有当 view 从布局文件中被 inflate 出来；第二种形式是解析和应用定义在布局文件中的属性</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onFinishInflate(" target="_blank" rel="external">onFinishInflate()</a>)</td>
<td>在 view 和其所有的 children 从 XML 中被 inflate 之后调用</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">布局 (Layout)</td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int" target="_blank" rel="external">onMeasure(int, int)</a>)</td>
<td>用来决定当前 view 和其所有 children 的尺寸时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onLayout(boolean,%20int,%20int,%20int,%20int" target="_blank" rel="external">onLayout(boolean, int,int, int, int)</a>)</td>
<td>当 view 应该分配其所有 children 的尺寸和位置时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onSizeChanged(int,%20int,%20int,%20int" target="_blank" rel="external">onSizeChanged(int, int,int, int)</a>)</td>
<td>当 view 的尺寸已经变化时被调用</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">绘制 (Drawing)</td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onDraw(android.graphics.Canvas" target="_blank" rel="external">onDraw(Canvas)</a>)</td>
<td>当 view 应该渲染其内容时被调用</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">事件处理 (Event processing)</td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onKeyDown(int,%20android.view.KeyEvent" target="_blank" rel="external">onKeyDown(int, KeyEvent)</a>)</td>
<td>当一个新的按键事件发生时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onKeyUp(int,%20android.view.KeyEvent" target="_blank" rel="external">onKeyUp(int, KeyEvent)</a>)</td>
<td>当一个按键抬起的事件发生时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onTrackballEvent(android.view.MotionEvent" target="_blank" rel="external">onTrackballEvent(MotionEvent)</a>)</td>
<td>当一个跟踪球动作事件发生时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onTouchEvent(android.view.MotionEvent" target="_blank" rel="external">onTouchEvent(MotionEvent)</a>)</td>
<td>当一个触屏动作事件发生时被调用</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">焦点 (Focus)</td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onFocusChanged(boolean,%20int,%20android.graphics.Rect" target="_blank" rel="external">onFocusChanged(boolean,int, Rect)</a>)</td>
<td>当 view 获取或失去焦点时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onWindowFocusChanged(boolean" target="_blank" rel="external">onWindowFocusChanged(boolean)</a>)</td>
<td>当窗口包括 view 获取或失去焦点时被调用</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">种类</th>
<th style="text-align:left">方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">依附 (Attaching)</td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onAttachedToWindow(" target="_blank" rel="external">onAttachedToWindow()</a>)</td>
<td>当 view 依附窗口时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onDetachedFromWindow(" target="_blank" rel="external">onDetachedFromWindow()</a>)</td>
<td>当 view 从其所在窗口分离时被调用</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><a href="https://developer.android.com/reference/android/view/View.html#onDetachedFromWindow(" target="_blank" rel="external">onDetachedFromWindow()</a>)</td>
<td>当包含 view 窗口的可见性改变时被调用</td>
</tr>
</tbody>
</table>
<h2 id="复合控制"><a href="#复合控制" class="headerlink" title="复合控制"></a><strong>复合控制</strong></h2><p>假如不想创建一个完全自定义的组件，而是试图将一个包括一组已存在控制的复用组件放在一起，然后新建一个满足要求的复合组件 (或复合控制)。概括来说，这将一系列更具原子性的控制 (或 views) 一起放进一个 items 逻辑组里，这可以当一个单一的事物来对待。举个例子，<code>Combo Box</code>可以被认为是一个单线 EditText 域和一个带有依附着 PopupList 连接 Button 的组合。若按下按钮，选中 list 中的某些 item，其会弹出 EditText 编辑框，但是若用户喜欢的话，他们也可以直接在 EditText 编辑框内输入东西。</p>
<p>Android 里，实际上有两种 Views 这样可用：<code>Spinner</code>和<code>AutoCompleteTextView</code>，然而，<code>Combo Box</code>的概念让这个实例很容易来理解。</p>
<p>为了创建一个复合组件：</p>
<ul>
<li>通常开始于某种 Layout，因此可以创建一个继承于某种 Layout 的类。大概在<code>Combo box</code>的例子里，我们或许会使用呈现水平方向的 LinearLayout。不过，别的布局可以在里面嵌套，因此，复合组件可以任意得复杂和结构化。注意就像在 Activity 里，我们可以使用基于 XML 的声明式的方法创建包括的组件，也可以在 Java 代码里动态地嵌套它们</li>
<li>在新类的构造器里，拿着父类希望的任何参数，然后首先传递至父类的构造器。然后，在新建的组件里，生成别的使用的 views，这是能创建 EditText 域和 PopupList 的地方。<strong>注意</strong>，也可以将 XML 里自定义的属性和参数拿出来在构造器里使用</li>
<li>也可以在容纳 views 或许产生的事件里创建监听器，举个例子，若一个 list 选中了，创建一个 List Item 点击监听器的监听方法，来更新 EditText 里的内容</li>
<li>或许也创建带有存储器和修饰器的自定义性能，举个例子，允许组件的 EditText 里初始时就带有值，然后在需要时查询所需的内容</li>
<li>在继承某种布局 Layout 的 case 里，不需要重写 onDraw() 和 onMeasure() 方法，因为 layout 其自带的行为也可能运转得很好。但是，我们仍然可以在需要时重写它们</li>
<li>或许要重写 on… 方法，像<code>onKeyDown()</code>，大概是按下某个键，在 combo box 弹出的 list 里选择默认的值</li>
</ul>
<p>总结来说，使用布局 Layout 来作为自定义控制的基础，其有一系列好处，包括：</p>
<ul>
<li>就像在 Activity 屏幕里一样，可以使用声明式 XML 文件来指定布局，或者可以动态地创建 views，然后在代码中嵌套它们</li>
<li>onDraw() 和 onMeasure() 方法 (甚至还有别的 on… 方法) 可能有着合适的行为，因此，我们往往不必多余地来重写这些方法</li>
<li>最后要说的是，我们可以迅速地构造任意复杂的复合 views，然后重用它们，好像它们就是单个组件</li>
</ul>
<h2 id="修改存在的视图类型"><a href="#修改存在的视图类型" class="headerlink" title="修改存在的视图类型"></a><strong>修改存在的视图类型</strong></h2><p>在某些情况下，甚至有一些更简单的有用的方法，来创建自定义 View。若有一个已经和你想要的组件十分相像，则可以简单地继承组件，只重写想要改变行为的方法。用完全自定义的组件，可以做任何想做的事，但是在 View 继承树里，开始于一个特殊的类，可以更自由地获取我们想要的行为。</p>
<p>举个例子，SDK 的 samples 里包括一个<a href="https://android.googlesource.com/platform/development/+/master/samples/NotePad/" target="_blank" rel="external">记事本应用</a>。其演示了使用 Android 平台的很多方面，里面有继承 EditText 视图来建立一个内衬记事本。这虽然不是一个完美的例子，实现这个的 APIs 或许和早起的预览有所不同，但是其确实有些参考作用。</p>
<p>若没做过的话，可以将 NotePad 样例导入至 Android Studio (或者只是使用提供的链接查看源码)。尤其，注意看 <a href="https://android.googlesource.com/platform/development/+/master/samples/NotePad/src/com/example/android/notepad/NoteEditor.java" target="_blank" rel="external">NoteEditor.java</a> 文件里自定义的 <code>MyEditText</code>，注意以下：</p>
<ul>
<li><p><strong>定义</strong></p>
<p>该类以下面的方式来定义，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEditText</span> <span class="keyword">extends</span> <span class="title">EditText</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>其在<code>NoteEditor</code>Activity 里，定义为一个内部类，但它是 public 的，因此其可以在<code>NoteEditor</code>之外任何需要的地方，以<code>NoteEditor.MyEditText</code>的方式获取</li>
<li>其是静态<code>static</code>的，意味着它不会生成所谓的假的方法，来允许它从父类中获取数据，反过来，这也意味着，它作为一个分离的类运转，而不是和<code>NoteEditor</code>强相关的东西。若不需要在外部类获取状态 state，以上所说的是一个更优雅的方式，让生成的类很小，允许其从别的类中被使用时很容易</li>
<li>它继承自<code>EditText</code>，即我们选择在这个 case 中要自定义的 View。当我们完成后，新类能够代表一个标准的<code>EditText</code> view</li>
</ul>
</li>
<li><p><strong>类初始化</strong></p>
<p>通常，父类构造方法首先被调用。此外，这不是一个默认的构造器，但是一个带有参数的构造器。当 EditText 从 XML 布局中被 inflate 后，其会同时带有这些参数被创建出来，因此，我们的构造器需要拿着它们，并将它们传递至父构造器</p>
</li>
<li><p><strong>重写方法</strong></p>
<p>这个例子里，只有一个被重写的方法，即<code>onDraw()</code>，但是在我们自建的自定义 View 里，很容易会出现其他需要的方法。</p>
<p>在 NotePad 样例里，重写<code>onDraw()</code>方法来让我们在<code>EditText</code>的画布 canvas (canvas 被传递至重写的<code>onDraw()</code>方法里) 上。<code>super.onDraw()</code>方法在该方法结束前调用。父类方法应该被调用，但是在这个 case 里，在我们绘制了我们想要的 lines 后，在方法最后调用了。</p>
</li>
<li><p><strong>使用自定义组件</strong></p>
<p>我们现在有了自己的自定义组件，但是我们怎样使用它呢？在 NotePad 样例里，自定义组件直接在声明式布局里使用，看看<code>res/layout</code>文件夹下的<code>note_editor.xml</code>文件如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;view</span><br><span class="line">  class=&quot;com.android.notepad.NoteEditor$MyEditText&quot;</span><br><span class="line">  id=&quot;@+id/note&quot;</span><br><span class="line">  android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">  android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">  android:background=&quot;@android:drawable/empty&quot;</span><br><span class="line">  android:padding=&quot;10dip&quot;</span><br><span class="line">  android:scrollbars=&quot;vertical&quot;</span><br><span class="line">  android:fadingEdge=&quot;vertical&quot; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>自定义组件在 XML 里新建为一个宽泛的 view，类指定使用全包名。注意，我们定义的内部类以 <strong>NoteEditor$MyEditText </strong> 注解的方式被引用，其也是 Java 里引用内部类的标准作法。</p>
<p>假如自定义组件不是作为内部类定义的，那么，可以用 XML 元素的名字声明 View 组件，且包括类属性，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.android.notepad.MyEditText</span></span><br><span class="line">  <span class="attr">id</span>=<span class="string">"@+id/note"</span></span><br><span class="line">  <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，这种情况下，<code>MyEditText</code>是一个分离的类文件。当类在<code>NoteEditor</code>类里嵌套的话，这样不起作用的。</p>
</li>
<li><p>定义中别的属性和参数，被传递至自定义的组件构造器里，然后传递过 EditText 构造器，因此，它们即是将在 EditText view 里使用的同样的参数。注意，把你自己的参数添加进去也是可能的。</p>
</li>
</ul>
</li>
</ul>
<p>以上皆提纲挈领，自定义 View 万变不离其宗。</p>
<p>至此，关于小结 Android 中的自定义 View 套路完毕。</p>
<p><strong><em>本人才疏学浅，如有疏漏错误之处，望读者中有识之士不吝赐教，谢谢。</em></strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Email: iamasoldiersix@gmail.com / WeChat: Wolverine623</span><br></pre></td></tr></table></figure>
<p><strong><em>您也可以关注我个人的微信公众号</em></strong> ：<strong><em>码农六哥</em></strong>，<strong><em>第一时间获得博客的更新通知，或后台留言与我交流</em></strong>。</p>
<p><img src="https://i.loli.net/2019/03/03/5c7b80d4d728b.jpg" alt=""></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><strong>参考文献</strong></h2><p>1.<a href="https://developer.android.com/guide/topics/ui/custom-components" target="_blank" rel="external">https://developer.android.com/guide/topics/ui/custom-components</a></p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/16/浅谈-Java-中的参数传递/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          浅谈 Java 中的参数传递
        
      </div>
    </a>
  
  
    <a href="/2018/05/06/浅谈-Android-中的富文本之强大的-SpannableString/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">浅谈 Android 中的富文本之强大的 SpannableString</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  

  
  <! -- 添加捐赠图标 -->
<div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
		   左边支付宝打赏，右边微信打赏。
        </span>
        <br>
      </div>  
	<div id="donate_guide" class="donate_bar center hidden" >
		<!-- 支付宝打赏图案 -->
		<img src="https://pic.superbed.cn/item/5c7bba683a213b041714b52b" alt="支付宝打赏"> 
		<!-- 微信打赏图案 -->
		<img src="https://pic.superbed.cn/item/5c7bbb573a213b041714c6e0" alt="微信打赏">  
    </div>
	<script type="text/javascript">
		document.getElementById('btn_donate').onclick = function(){
			$('#donate_board').addClass('hidden');
			$('#donate_guide').removeClass('hidden');
		}
	</script>
</div>
<! -- 添加捐赠图标 -->



      <! -- 添加版权信息 -->
<div class="article-footer-copyright">
<left>本文由<b> <a href="/index.html" target="_blank" title="Iamasoldier6">Iamasoldier6</a> </b>创作和发表，采用<b>署名</b>-<b>非商用</b>-<b>禁止演绎 3.0 </b>国际许可协议进行许可。<br/></left>

<left>非商业转载请注明作者及出处，商业转载请联系作者本人。<br/>本文作者：<b><a href="/index.html" target="_blank" title="Iamasoldier6">Iamasoldier6</a></b><br/>本文标题：<b><a href="/2018/05/19/小结-Android-中的自定义-View-套路/" target="_blank" title="小结 Android 中的自定义 View 套路">小结 Android 中的自定义 View 套路</a></b></left>

<left><br/>本文链接：<b><a href="/2018/05/19/小结-Android-中的自定义-View-套路/" target="_blank" title="小结 Android 中的自定义 View 套路">http://iamasoldier6.com/2018/05/19/小结-Android-中的自定义-View-套路/</a></b></left>
</div>
<! -- 添加版权信息 -->
    
</article>


<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>









</div>
      
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-75799138-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->




<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



<div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>
<script src="/js/totop.js"></script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?4548ab92471a76e452c9750997a514f8";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  </div>
</body>
</html>